V tejto kapitole predstavíme naše riešenie \emph{problému indexovania readov} -- dátovú štruktúru \emph{CR-index} (z eng. \emph{Compressed Read index}), ktorá je navrhnutá tak, aby sa vyhla nedostatkom, ktorými trpia riešenia s použitím \emph{GkArray} alebo hash mapy. Pripomeňme, že úlohou tejto dátovej štruktúry bude efektívne (najmä vzhľadom na pamäť) zaindexovať veľkú sadu relatívne krátkych reťazcov nad malou abecedou -- \emph{sequence readov} -- a má vedieť odpovedať na dotaz \emph{,,vráť mi všetky ready také, že obsahujú $p$ ako podreťazec``}.
%\section{R-index}
% spravime crappy preproces a vysvetlime koncepty?

%- hlavna myslienka, ideme ready komprimovat, mohol by som mat SS bez editov, to bolo nanic, dovolime chyby, komplikuje to situaciu, ale je to gain, ako to navonok funguje - ake queries chceme atd.
%- ako funguju queries
%- popis vnutorneho fungovania
%- popis ako to vyrobime - trivialne - crappy preprocess (a potom ako lepsie)

\section{Princíp fungovania}

\subsection{Komprimácia vstupu}
Kým \emph{GkArray} ready zo vstupu iba zreťazil a nad týmto dlhým reťazcom potom budoval sufixové polia a ostatné pomocné štruktúry, hlavnou myšlienkou \emph{CR-indexu} je, ako už napovedá názov, ready najprv vhodným spôsobom skomprimovať a až potom ďalej spracovávať. Využijeme to, že reťazce, ktoré máme za úlohu indexovať majú čosi spoločné -- vznikli sekvenovaním jedného genómu. Keďže pokrytie sa pri sekvenovaní zvyčajne pohybuje na úrovni $10\times$ -- $100\times$, znamená to, že ready obsahujú veľké množstvo nadbytočných informácií. Pomocou nejakého assembleru čiastočne zrekonštruujeme pôvodný genóm \todo{vysvetlit v 1. kapitole co je asembler} -- čiastočne preto, lebo výstupom assemblerov pre nejakú sadu readov nebýva vo všeobecnosti súvislý genóm, ale len sada kontigov resp. superkontig.\todo{vysvetlit kontig/superkontig v 1. kapitole}. Tiež nemáme zaručené, že každý read zo vstupu sa v niektorom kontigu musí nachádzať. Tieto chýbajúce ready potom musíme efektívne nájsť a nejakým spôsobom pridať ku kontigom, aby sme neprišli o žiadnu informáciu.

Pre začiatok predpokladajme, že ready na vstupe sú bez sekvenovacích chýb -- to znamená, že pre každý read platí, že je podreťazcom pôvodného genómu, ktorý bol sekvenovaný. Assembler by mal byť pri rekonštruovaní genómu pomerne úspešný (samozrejme ak majú ready dostatočné pokrytie) a relatívne málo readov by malo chýbať medzi kontigmi. V tomto prípade by sme teda spolu zreťazili kontigy a všetky chýbajúce ready -- tým dostaneme bezstratovo komprimovaný vstup. Ako ale nájdeme ready, ktoré nie sú podreťazcom zreťazenia kontigov? Jednoducho -- nad zreťazením kontigov skonštruujeme FM-index, ktorého sa postupne budeme pýtať na všetky ready zo vstupu (a ich reverzné komplementy) a v prípade, že FM-index tento read (ani jeho reverzný komplement) nenájde, označíme ho ako chýbajúci.

Výsledkom komprimačnej fázy je teda zreťazenie kontigov a readov zo vstupu, ktoré nie sú podreťazcom zreťazenia kontigov a ani ich reverzný komplement nie je podreťazcom zreťazenia kontigov. Tento dlhý reťazec nazveme \emph{superstring} (neskôr ho definujeme aj formálne).

\subsection{Index}
\label{ssec:index}
V ďalšej fáze konštrukcie CR-indexu vytvoríme nad superstringom (opäť) FM-index. V tejto chvíli sme už schopní efektívne vyhľadávať vzorky v superstringu, no keď nám operácia FM-indexu \emph{locate} vráti zoznam pozícií superstringu, kde sa daná vzorka nachádza, nevieme z toho povedať ktorým readom tieto pozície prislúchajú. Potrebujeme si teda predrátať, kde sa ktorý read nachádza. Na to použijeme pole \emph{positions} -- jeho prvkami budú trojice $(i, r, b)$ - $i$ bude označovať index v superstringu, kde začína read $r$. Logická premenná $b$ označuje, či sa v superstringu nachádza samotný read ($b=0$) alebo jeho reverzný komplement ($b=1$). Algoritmus na konštrukciu CR-indexu teda vyzerá nasledovne\footnote{Táto implementácia slúži len pre účely vysvetlenia konštrukcie CR-indexu. Reálna implementácia vyzerá trochu odlišne a popíšeme ju v kapitole \ref{ch:implementacia}.}:

\bigskip
\begin{pseudocode}[label=lst:cr_index_construction,caption={Algoritmus konštrukcie CR-indexu nad readmi bez chýb.}]
assembler = Assembler.new <* \label{lst:cr_index_construction_assembler} *>
superstring = ""
positions = Array.new

contigs = assembler.assemble(R) <* \label{lst:cr_index_construction_assemble} *>
foreach c : contigs do <* \label{lst:cr_index_construction_contigs_start} *>
  superstring += c 
end <* \label{lst:cr_index_construction_contigs_end} *>

contigs_fm_index = FMIndex.new(joint_contigs) <* \label{lst:cr_index_construction_fm_index} *>

foreach r : R  do
  matches = contigs_fm_index.locate(r) <* \label{lst:cr_index_construction_locate} *>
  matches2 = contigs_fm_index.locate(rev_compl(r)) <* \label{lst:cr_index_construction_rev_compl} *>

  if matches.size() == 0 && matches2.size() 
    positions.push(superstring.length(), r, 0) <* \label{lst:cr_index_construction_push} *> 
    superstring += r <* \label{lst:cr_index_construction_superstring_r} *>  
  else
    foreach m : matches do
      positions.push([m, r, 0]) <* \label{lst:cr_index_construction_push2} *>  
    end
    
    foreach m : matches2 do
      positions.push([m, r, 1]) <* \label{lst:cr_index_construction_push3} *>  
    end
  end
end

positions.sort <* \label{lst:cr_index_construction_sort} *>  
fm_index = FMIndex.new(superstring) <* \label{lst:cr_index_construction_fm_index2} *>
\end{pseudocode}
\bigskip

Premenná $R$ označuje množinu readov, ktorú máme na vstupe. Objekt \emph{assembler} (riadok \ref{lst:cr_index_construction_assembler}) predstavuje zapuzdrenie volania vhodného assemblera, jeho metóda \emph{assemble} (riadok \ref{lst:cr_index_construction_assemble}) vracia pre pole readov na vstupe pole reťazcov predstavujúcich kontigy, ktoré assembler poskladal z readov. Objekt \emph{FM-index} (riadok \ref{lst:cr_index_construction_fm_index}) je vhodná implementácia FM-indexu podporujúca operáciu \emph{locate} (viď. kapitolu \ref{sec:fm_index}), ktorá pre vzorku na vstupe vráti pole indexov reťazca nad ktorým je tento FM-index skonštruovaný, na ktorých daná vzorka začína. Funkcia \emph{rev\_compl(s)} (riadok \ref{lst:cr_index_construction_rev_compl}) vracia pre reťazec na vstupe jeho reverzný komplement (podľa definície \ref{def:reverzny_komplement}).

Algoritmus najprv zavolá assembler (riadok \ref{lst:cr_index_construction_assemble}), pomocou ktorého vytvorí kontigy, ktoré zreťazí (riadky \ref{lst:cr_index_construction_contigs_start} -- \ref{lst:cr_index_construction_contigs_end}). Potom prebehne konštrukcia pomocného FM-indexu (riadok \ref{lst:cr_index_construction_fm_index}) nad zreťazenými kontigmi. Následne sa pre každý read $r$ a jeho reverzný komplement zavoláme metódu \emph{locate} tohto FM-indexu (riadky \ref{lst:cr_index_construction_locate} -- \ref{lst:cr_index_construction_rev_compl}). Ak sa ani jeden z nich v superstringu nenachádza, tak ho tam pridáme (riadok \ref{lst:cr_index_construction_superstring_r}). Už predtým už ale vieme, na akej pozícii bude tento read v superstringu začínať (keďže ho pridávame na koniec) a môžeme túto informáciu vložiť do poľa \emph{positions} (riadok \ref{lst:cr_index_construction_push}). Pre ready, ktoré sa v superstringu nachádzajú pridáme do poľa \emph{positions} informáciu o ich výskytoch (riadok \ref{lst:cr_index_construction_push2}) resp. výskytoch ich reverzných komplementov (riadok \ref{lst:cr_index_construction_push3}). Pole \emph{positions} nakoniec utriedime (riadok \ref{lst:cr_index_construction_sort}) -- ako uvidíme v ďalšej časti, pomôže nám to rýchlejšie identifikovať ready obsahujúce hľadanú vzorku. Nad superstringom, ktorý sme úspešne zreťazili so všetkými chýbajúcimi readmi potom skonštruujeme nový FM-index (riadok \ref{lst:cr_index_construction_fm_index2}). Práve ten spolu s poľom \emph{positions} predstavujú výstup konštrukcie celého CR-indexu.

\subsection{Dotazy}
Úlohou je pre reťazec $p$ na vstupe vrátiť tie ready, ktoré obsahujú $p$ ako podreťazec. Najprv uvedieme algoritmus v pseudokóde a potom ho vysvetlíme:

\bigskip
\begin{pseudocode}[label=lst:cr_index_query,caption={Algoritmus dotazu \emph{locate} CR-indexu nad readmi bez chýb.}]
def locate(p)
  retval = Array.new
  indexes = fm_index.locate(p) <* \label{lst:cr_index_query_locate} *>  
  
  foreach i : indexes do <* \label{lst:cr_index_query_foreach} *>  
    start_index = [i + k - l, -1, 0] <* \label{lst:cr_index_query_start_index} *>  
    end_index = [i, INT_MAX, 1] <* \label{lst:cr_index_query_end_index} *>  
    
    low = positions.lower_bound(start_index) <* \label{lst:cr_index_query_low} *>  
    up = positions.upper_bound(end_index) <* \label{lst:cr_index_query_up} *>  
    
    foreach pos : (low..up) do <* \label{lst:cr_index_query_foreach2} *>
      if (pos[2] == 0)
        retval.push(pos[1]) <* \label{lst:cr_index_query_push_read} *>
      else
        retval.push(rev_compl(pos[1])) <* \label{lst:cr_index_query_push_rev_compl} *>
      end
    end
  end
  
  return retval
end
\end{pseudocode}
\bigskip

Premenné $fm\_index$ a $positions$ sú výsledkom konštrukcie z časti \ref{ssec:index}, premenná $l$ predstavuje dĺžku každého readu, premenná $k$ má hodnotu dĺžky dotazu (podľa toho, ako sme problém \emph{indexovania readov} zadefinovali v časti \ref{sec:definicia_problemu} máme obe hodnoty k dispozícii na vstupe pri konštrukcii CR-indexu, t.j. predstavujú parametre konštrukcie) a konštanta $INT\_MAX$ je najväčšia hodnota pre celočíselný dátový typ.

V prvom kroku vyhľadáme výskyty $p$ v superstringu pomocou FM-indexu (riadok \ref{lst:cr_index_query_locate}), ktorý sme skonštruovali počas predchádzajúcej fázy -- výsledkom bude zoznam pozícií v superstringu, kde bola vzorka $p$ nájdená. Následne potrebujeme tieto pozície preložiť na ready, ktorým prislúchajú a na to využijeme pole \emph{positions}. To spravíme tak, že v ňom pre každý index $i$ (riadok \ref{lst:cr_index_query_foreach}) pomocou binárneho vyhľadávania obmedzíme rozsah, kde sa nachádzajú relevantné hodnoty -- tie prvky, ktoré označujú začiatky readov, ktoré obsahujú ako podreťazec tento výskyt hľadanej vzorky. Práve tu využijeme to, že toto pole je utriedené podľa prvej súradnice -- indexu ukazujúceho na pozíciu v superstringu. Metódy $lower\_bound$\footnote{Podľa \url{http://www.cplusplus.com/reference/algorithm/lower_bound/}} (riadok \ref{lst:cr_index_query_low}) resp. $upper\_bound$ (riadok \ref{lst:cr_index_query_up}) vrátia takú pozíciu v poli, že hodnota na tejto pozícii nie je menšia resp. je väčšia ako $start\_index$ resp. $end\_index$. Pre $start\_index$ preto zvolíme hodnotu, ktorá popisuje najľavejší index v superstringu taký, že read na ňom začínajúci môže obsahovať výskyt vzorky $p$ začínajúci na indexe $i$ (pre $end\_index$ analogicky najpravejší read). Všetky takto ohraničené hodnoty poľa \emph{positions} (riadok \ref{lst:cr_index_query_foreach2}) predstavujú ready, ktoré obsahujú tento výskyt vzorky $p$ -- posledné, čo ostáva je pridať do výstupného poľa \emph{retval} tento read (riadok \ref{lst:cr_index_query_push_read}) resp. jeho reverzný komplement (riadok \ref{lst:cr_index_query_push_rev_compl}) -- podľa toho, ktorý z nich je v superstringu uložený (a indikátor toho sme si pri konštrukcii poľa \emph{positions} uložili ako tretiu hodnotu pre každý prvok). Metóda \emph{locate} teda pre hľadanú vzorku $p$ vráti zoznam readov, ktoré ju obsahujú ako podreťazec. Pre splnenie poslednej podmienky z časti \ref{sec:definicia_problemu} by sme pre dotaz na vzorku $p$ mali zavolať metódu \emph{locate} aj pre vstup $rev\_compl(p)$ a výstupy pre obe volania spojiť do jedného poľa a vrátiť ako výstup to.

\todo{obrazok ako je v suerstringu vzorka a obsahuju ju dva ready prekryvajuce sa, ukazat tam to i+k-l}

\todo{priklad na komplet superstring + query}

\section{Ready s chybami}
Bohužiaľ, zjednodušením situácie vo forme popierania existencie sekvenovacích chýb sa až príliš vzďaľujeme realite. Ako sa teda zmení situácia, ak máme brať do úvahy, že v readoch sa vyskytujú chyby?

Pripomeňme, že pri probléme \emph{indexovania readov} tak, ako sme ho zadefinovali v kapitole \ref{ch:problem_indexovania_readov} uvažujeme len substitučné chyby -- čo znamená, že read sa môže v niektorých bázach líšiť od svojho ,,obrazu`` v pôvodnom genóme.

V prvom rade assembler nebude pri konštrukcii kontigov ani zďaleka tak úspešný ako v predchádzajúcom prípade -- chyby budú znižovať pravdepodobnosť, že úspešne odhalí prekryvy medzi readmi, ciže výstupom assembleru budú oveľa kratšie kontigy, čiže aj ,,kompresný pomer`` bude výrazne nižší a to viac readov bude potrebné pripojiť na koniec. Ak si uvedomíme, že pri indexovaní readov napríklad s dĺžkou 100 báz a chybovosťou $1\%$ má takmer každý read aspoň jednu chybu, vidíme, že tento spôsob indexovania je pre ready s chybami nepostačujúci a komprimáciu vstupu je potrebné robiť sofistikovanejšie.

,,Komprimovateľnosť`` readov zvýšime tak, že pred tým, ako ich dostane assembler na vstup budú opravené -- korekcia readov (\emph{sequencing read correction}) je známy problém, na ktorý existuje množstvo riešení. \todo{sem by sa hodili nejake citacie} Čo nám ale skomplikuje situáciu je fakt, že kontigy budú obsahovať opravené ready a nie originálne, ktoré sme dostali na vstupe -- preto si budeme musieť pamätať aj ďalšie informácie týkajúce sa aplikovaných korekcií, aby sme vedeli prevádzať transformácie medzi opravenými a neopravenými readmi. Tým sme však stále nevyriešili situáciu, čo s chýbajúcimi readmi. Ak by sme v zreťazených kontigoch hľadali pôvodné, neopravené ready, chýbalo by ich, pochopiteľne, veľmi veľa a tým pádom by komprimácia nebola tak úspešná. Zvoľme opačný prístup -- v zreťazených kontigoch budeme hľadať opravené ready a tie, ktoré v kontigoch nie sú obsiahnuté zreťazíme na koniec. Zamyslime sa teraz, ako by prebiehal dotaz -- ak existuje výsky vzorky $p$ v superstringu, znamená to, že nejaký \emph{opravený} read obsahuje hľadanú vzorku. To ale neznamená, že ju obsahoval aj pôvodný read -- našťastie túto situáciu vieme ľahko vyriešiť pomocou zapamätaných korekcií -- k danému opravenému readu skonštruujeme pôvodný a v ňom overíme, či je $p$ jeho podreťazcom. Týmto spôsobom vieme vylúčiť \emph{false positives}. Problematickejšie to bude z druhej strany -- vieme ale takto nájsť \emph{všetky} výskyty vzorky $p$ medzi pôvodnými readmi? Uvažujme nasledovný príklad:

\todo{priklad. ready, opravene ready, kontigy nad nimi. jeden povodny read obsahoval nejaku vzorku p, ale korekcia ho dost masivne upravila. eventualne treba skusat prilis vela korekcii p}

V konečnom dôsledku teda vidno, že vhodný prístup leží kdesi uprostred možností zreťaziť s kontigmi (nad opravenými readmi) povodné a opravené ready.

% aha, musime to spravit takto, definujeme kriticke ready, tie sa supnu na koniec


%Výsledkom fázy komprimácie teda bude zreťazenie kontigov\footnote{neskôr ukážeme, že k nemu ešte niečo budeme musieť pridať} - to nazveme \emph{superstring} (formálne definujeme neskôr) a pole nejakým spôsobom popisujúce aplikované korekcie.

%V našej práci sme použili implementáciu \emph{SGA} (\emph{String Graph Assembler} \cite{SD11}) dostupnú na internete\footnote{\url{https://github.com/jts/sga}}. 