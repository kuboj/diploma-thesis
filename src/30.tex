V tejto kapitole predstavíme naše riešenie \emph{problému indexovania readov} -- dátovú štruktúru \emph{CR-index} (z eng. \emph{Compressed Read index}), ktorá je navrhnutá tak, aby sa vyhla nedostatkom, ktorými trpia riešenia s použitím \emph{GkArray} alebo hash mapy. Pripomeňme, že úlohou tejto dátovej štruktúry bude efektívne (najmä vzhľadom na pamäť) zaindexovať veľkú sadu relatívne krátkych reťazcov nad malou abecedou -- \emph{sequence readov} -- a má vedieť odpovedať na dotaz \emph{,,vráť mi všetky ready také, že obsahujú $p$ ako podreťazec``}.

\section{Princíp fungovania}

\subsection{Komprimácia vstupu}
Kým \emph{GkArray} ready zo vstupu iba zreťazil a nad týmto dlhým reťazcom potom budoval sufixové polia a ostatné pomocné štruktúry, hlavnou myšlienkou \emph{CR-indexu} je, ako už napovedá názov, ready najprv vhodným spôsobom skomprimovať a až potom ďalej spracovávať. Využijeme to, že reťazce, ktoré máme za úlohu indexovať majú čosi spoločné -- vznikli sekvenovaním jedného genómu. Keďže pokrytie sa pri sekvenovaní zvyčajne pohybuje na úrovni $10\times$ -- $100\times$, znamená to, že ready obsahujú veľké množstvo nadbytočných informácií. Pomocou nejakého assembleru čiastočne zrekonštruujeme pôvodný genóm -- čiastočne preto, lebo výstupom assemblerov pre nejakú sadu readov nebýva vo všeobecnosti súvislý genóm, ale len sada kontigov resp. superkontig. Tiež nemáme zaručené, že každý read zo vstupu sa v niektorom kontigu musí nachádzať. Tieto chýbajúce ready potom musíme efektívne nájsť a nejakým spôsobom pridať ku kontigom, aby sme neprišli o žiadnu informáciu.

Pre začiatok predpokladajme, že ready na vstupe sú bez sekvenovacích chýb -- to znamená, že pre každý read platí, že je podreťazcom pôvodného genómu, ktorý bol sekvenovaný. Assembler by mal byť pri rekonštruovaní genómu pomerne úspešný (samozrejme ak majú ready dostatočné pokrytie) a relatívne málo readov by malo chýbať medzi kontigmi. V tomto prípade by sme teda spolu zreťazili kontigy a všetky chýbajúce ready -- tým dostaneme bezstratovo komprimovaný vstup. Ako ale nájdeme ready, ktoré nie sú podreťazcom zreťazenia kontigov? Jednoducho -- nad zreťazením kontigov skonštruujeme FM-index, ktorého sa postupne budeme pýtať na všetky ready zo vstupu (a ich reverzné komplementy) a v prípade, že FM-index tento read (ani jeho reverzný komplement) nenájde, označíme ho ako chýbajúci.

Výsledkom komprimačnej fázy je teda zreťazenie kontigov a readov zo vstupu, ktoré nie sú podreťazcom zreťazenia kontigov a ani ich reverzný komplement nie je podreťazcom zreťazenia kontigov. Tento dlhý reťazec nazveme \emph{superstring} (neskôr ho definujeme aj formálne).

\subsection{Index}
\label{ssec:index}
V ďalšej fáze konštrukcie CR-indexu vytvoríme nad superstringom (opäť) FM-index. V tejto chvíli sme už schopní efektívne vyhľadávať vzorky v superstringu, no keď nám operácia FM-indexu \emph{locate} vráti zoznam pozícií superstringu, kde sa daná vzorka nachádza, nevieme z toho povedať ktorým readom tieto pozície prislúchajú. Potrebujeme si teda predrátať, kde sa ktorý read nachádza. Na to použijeme pole \emph{positions} -- jeho prvkami budú trojice $(i, r, b)$ - $i$ bude označovať index v superstringu, kde začína read $r$. Logická premenná $b$ označuje, či sa v superstringu nachádza samotný read ($b=0$) alebo jeho reverzný komplement ($b=1$). Algoritmus na konštrukciu CR-indexu teda vyzerá nasledovne\footnote{Táto implementácia slúži len pre účely vysvetlenia konštrukcie CR-indexu. Reálna implementácia vyzerá trochu odlišne a popíšeme ju v kapitole \ref{ch:implementacia}.}:

\bigskip
\begin{pseudocode}[label=lst:cr_index_construction,caption={Algoritmus konštrukcie CR-indexu nad readmi bez chýb.}]
assembler = Assembler.new <* \label{lst:cr_index_construction_assembler} *>
superstring = ""
positions = Array.new

contigs = assembler.assemble(R) <* \label{lst:cr_index_construction_assemble} *>
foreach c : contigs do <* \label{lst:cr_index_construction_contigs_start} *>
  superstring += c 
end <* \label{lst:cr_index_construction_contigs_end} *>

contigs_fm_index = FMIndex.new(joint_contigs) <* \label{lst:cr_index_construction_fm_index} *>

foreach r : R  do
  matches = contigs_fm_index.locate(r) <* \label{lst:cr_index_construction_locate} *>
  matches2 = contigs_fm_index.locate(rev_compl(r)) <* \label{lst:cr_index_construction_rev_compl} *>

  if matches.size() == 0 && matches2.size() 
    positions.push(superstring.length(), r, 0) <* \label{lst:cr_index_construction_push} *> 
    superstring += r <* \label{lst:cr_index_construction_superstring_r} *>  
  else
    foreach m : matches do
      positions.push([m, r, 0]) <* \label{lst:cr_index_construction_push2} *>  
    end
    
    foreach m : matches2 do
      positions.push([m, r, 1]) <* \label{lst:cr_index_construction_push3} *>  
    end
  end
end

positions.sort <* \label{lst:cr_index_construction_sort} *>  
fm_index = FMIndex.new(superstring) <* \label{lst:cr_index_construction_fm_index2} *>
\end{pseudocode}
\bigskip

Premenná $R$ označuje množinu readov, ktorú máme na vstupe. Objekt \emph{assembler} (riadok \ref{lst:cr_index_construction_assembler}) predstavuje zapuzdrenie volania vhodného assemblera, jeho metóda \emph{assemble} (riadok \ref{lst:cr_index_construction_assemble}) vracia pre pole readov na vstupe pole reťazcov predstavujúcich kontigy, ktoré assembler poskladal z readov. Objekt \emph{FM-index} (riadok \ref{lst:cr_index_construction_fm_index}) je vhodná implementácia FM-indexu podporujúca operáciu \emph{locate} (viď. kapitolu \ref{sec:fm_index}), ktorá pre vzorku na vstupe vráti pole indexov reťazca nad ktorým je tento FM-index skonštruovaný, na ktorých daná vzorka začína. Funkcia \emph{rev\_compl(s)} (riadok \ref{lst:cr_index_construction_rev_compl}) vracia pre reťazec na vstupe jeho reverzný komplement (podľa definície \ref{def:reverzny_komplement}).

Algoritmus najprv zavolá assembler (riadok \ref{lst:cr_index_construction_assemble}), pomocou ktorého vytvorí kontigy, ktoré zreťazí (riadky \ref{lst:cr_index_construction_contigs_start} -- \ref{lst:cr_index_construction_contigs_end}). Potom prebehne konštrukcia pomocného FM-indexu (riadok \ref{lst:cr_index_construction_fm_index}) nad zreťazenými kontigmi. Následne sa pre každý read $r$ a jeho reverzný komplement zavoláme metódu \emph{locate} tohto FM-indexu (riadky \ref{lst:cr_index_construction_locate} -- \ref{lst:cr_index_construction_rev_compl}). Ak sa ani jeden z nich v superstringu nenachádza, tak ho tam pridáme (riadok \ref{lst:cr_index_construction_superstring_r}). Už predtým už ale vieme, na akej pozícii bude tento read v superstringu začínať (keďže ho pridávame na koniec) a môžeme túto informáciu vložiť do poľa \emph{positions} (riadok \ref{lst:cr_index_construction_push}). Pre ready, ktoré sa v superstringu nachádzajú pridáme do poľa \emph{positions} informáciu o ich výskytoch (riadok \ref{lst:cr_index_construction_push2}) resp. výskytoch ich reverzných komplementov (riadok \ref{lst:cr_index_construction_push3}). Pole \emph{positions} nakoniec utriedime (riadok \ref{lst:cr_index_construction_sort}) -- ako uvidíme v ďalšej časti, pomôže nám to rýchlejšie identifikovať ready obsahujúce hľadanú vzorku. Nad superstringom, ktorý sme úspešne zreťazili so všetkými chýbajúcimi readmi potom skonštruujeme nový FM-index (riadok \ref{lst:cr_index_construction_fm_index2}). Práve ten spolu s poľom \emph{positions} predstavujú výstup konštrukcie celého CR-indexu.

\subsection{Dotazy}
Úlohou je pre reťazec $p$ na vstupe vrátiť tie ready, ktoré obsahujú $p$ ako podreťazec. Najprv uvedieme algoritmus v pseudokóde a potom ho vysvetlíme:

\bigskip
\begin{pseudocode}[label=lst:cr_index_query,caption={Algoritmus dotazu \emph{locate} CR-indexu nad readmi bez chýb.}]
def locate(p)
  retval = Array.new
  indexes = fm_index.locate(p) <* \label{lst:cr_index_query_locate} *>  
  
  foreach i : indexes do <* \label{lst:cr_index_query_foreach} *>  
    start_index = [i + k - l, -1, 0] <* \label{lst:cr_index_query_start_index} *>  
    end_index = [i, INT_MAX, 1] <* \label{lst:cr_index_query_end_index} *>  
    
    low = positions.lower_bound(start_index) <* \label{lst:cr_index_query_low} *>  
    up = positions.upper_bound(end_index) <* \label{lst:cr_index_query_up} *>  
    
    for (pos = low; pos != up; pos++) do <* \label{lst:cr_index_query_foreach2} *>
      if (pos[2] == 0)
        retval.push(pos[1]) <* \label{lst:cr_index_query_push_read} *>
      else
        retval.push(rev_compl(pos[1])) <* \label{lst:cr_index_query_push_rev_compl} *>
      end
    end
  end
  
  return retval
end
\end{pseudocode}
\bigskip

Premenné $fm\_index$ a $positions$ sú výsledkom konštrukcie z časti \ref{ssec:index}, premenná $l$ predstavuje dĺžku každého readu, premenná $k$ má hodnotu dĺžky dotazu (podľa toho, ako sme problém \emph{indexovania readov} zadefinovali v časti \ref{sec:definicia_problemu} máme obe hodnoty k dispozícii na vstupe pri konštrukcii CR-indexu, t.j. predstavujú parametre konštrukcie) a konštanta $INT\_MAX$ je najväčšia hodnota pre celočíselný dátový typ.

V prvom kroku vyhľadáme výskyty $p$ v superstringu pomocou FM-indexu (riadok \ref{lst:cr_index_query_locate}), ktorý sme skonštruovali počas predchádzajúcej fázy -- výsledkom bude zoznam pozícií v superstringu, kde bola vzorka $p$ nájdená. Následne potrebujeme tieto pozície preložiť na ready, ktorým prislúchajú a na to využijeme pole \emph{positions}. To spravíme tak, že v ňom pre každý index $i$ (riadok \ref{lst:cr_index_query_foreach}) pomocou binárneho vyhľadávania obmedzíme rozsah, kde sa nachádzajú relevantné hodnoty -- tie prvky, ktoré označujú začiatky readov, ktoré obsahujú ako podreťazec tento výskyt hľadanej vzorky. Práve tu využijeme to, že toto pole je utriedené podľa prvej súradnice -- indexu ukazujúceho na pozíciu v superstringu. Metódy $lower\_bound$\footnote{Podľa \url{http://www.cplusplus.com/reference/algorithm/lower_bound/}} (riadok \ref{lst:cr_index_query_low}) resp. $upper\_bound$ (riadok \ref{lst:cr_index_query_up}) vrátia takú pozíciu v poli, že hodnota na tejto pozícii nie je menšia resp. je väčšia ako $start\_index$ resp. $end\_index$. Pre $start\_index$ preto zvolíme hodnotu, ktorá popisuje najľavejší index v superstringu taký, že read na ňom začínajúci môže obsahovať výskyt vzorky $p$ začínajúci na indexe $i$ (pre $end\_index$ analogicky najpravejší read. Viď príklad \ref{ex:najlavejsi_najpravejsi_read}). Všetky takto ohraničené hodnoty poľa \emph{positions} (riadok \ref{lst:cr_index_query_foreach2}) predstavujú ready, ktoré obsahujú tento výskyt vzorky $p$ -- posledné, čo ostáva je pridať do výstupného poľa \emph{retval} tento read (riadok \ref{lst:cr_index_query_push_read}) resp. jeho reverzný komplement (riadok \ref{lst:cr_index_query_push_rev_compl}) -- podľa toho, ktorý z nich je v superstringu uložený (a indikátor toho sme si pri konštrukcii poľa \emph{positions} uložili ako tretiu hodnotu pre každý prvok). Metóda \emph{locate} teda pre hľadanú vzorku $p$ vráti zoznam readov, ktoré ju obsahujú ako podreťazec. Pre splnenie poslednej podmienky z časti \ref{sec:definicia_problemu} by sme pre dotaz na vzorku $p$ mali zavolať metódu \emph{locate} aj pre vstup $rev\_compl(p)$ a výstupy pre obe volania spojiť do jedného poľa a vrátiť ako výstup to.

\bigskip
\begin{example}
\label{ex:najlavejsi_najpravejsi_read}
Ilustrácia toho, ako by mohol vyzerať najľavejší a najpravejší read v superstringu pre vzorku $p=GTCG$, $k=3$, $l=10$. Ak vzorka $p$ začína v superstringu na indexe $i$, tak najľavejší read začína na indexe $i+k-l$ a najpravejší na indexe $i$.

$$
  ss=
  \ldots
  ACTTG
  \rlap{$\overbracket{\phantom{ATACCG              \mathbf{GTCG}}}^{read 1}$}
                               ATACCG\underbracket{\mathbf{GTCG}             AAAAAA}_{read 2}
  GGTC
  \ldots
$$
\end{example}
\bigskip

\begin{example}
Uvažujme sadu readov $R=\{AAATTG, AATTGG, ATTGGC, GCCCAA,\\ CCCATA, $ $GGTAAT, GTAATC, TAATCA, ATCAAA\}$, kde $l=6$ a $p=4$. Ďalej predpokladajme, že výstupom assemblera sú kontigy $c_0=AAATTGGCCCAA$ \\ a $c_1=TTGATTACC$. Ich zreťazením a doplnením chýbajúcich reťazcov dostávame nasledovný superstring: \\
$$
  ss=
  \overbracket{AAATTGGCCCAA}^{c_1}
  \underbracket{TTGATTACC}_{c_2}
  \overbracket{CCCATA}^{r_3}
  \underbracket{ATCAAA}_{r_7}
$$
Pole \emph{positions} potom vyzerá nasledovne:

\begin{center}
    \begin{tabular}{ | c | c | c | }
        \hline
        \textbf{i} & \textbf{read} & \textbf{rev\_compl?} \\ \hline
        0  & AAATTG & 0 \\ \hline
        1  & AATTGG & 0 \\ \hline
        2  & ATTGGC & 0 \\ \hline
        6  & GCCCAA & 0 \\ \hline
        13 & TAATCA & 1 \\ \hline
        14 & GTAATC & 1 \\ \hline
        15 & GGTAAT & 1 \\ \hline
        21 & CCCATA & 0 \\ \hline
        27 & ATCAAA & 0 \\ \hline
    \end{tabular}
\end{center}
\bigskip

Ilustrujme dotaz pre vzorku $p=AAT$:
$$
A\mathbf{AAT}TGGCCCAATTGATTACCCCCAT\mathbf{AAT}CAAA
$$
Vidíme, že FM-index nad superstringom nám ako výsledok vrátil dve hodnoty -- 1 a 26. Ak $i=1$, potom začiatok najľavejšieho readu, ktorý môže vzorku obsahovať je 0, začiatok najpravejšieho 1, iterátor \emph{low} (riadok \ref{lst:cr_index_query_low} listingu \ref{lst:cr_index_query}) ukazuje na index 0 poľa \emph{positions} a iterátor \emph{up} (riadok \ref{lst:cr_index_query_up}) na pozíciu 2 (túto hodnotu už iterátor \emph{pos} pri iterovaní (riadok \ref{lst:cr_index_query_foreach2}) nenabudne). Výsledkom teda budú ready začínajúce na indexoch 0 a 1 -- $AAATTG$ a $AATTGG$.

Pokračujme pre $i=26$. Iterátor \emph{low} bude ukazovať na index 8 v poli \emph{positions} (lebo najľavejší read obsahujúci tento výsky vzorky $p$ môže začínať na indexe 23). Iterátor \emph{up} bude ukazovať tiež na index 8, takže cyklus \emph{for} na riadku \ref{lst:cr_index_query_foreach2} sa nevykoná ani raz -- čo je v poriadku, keďže síce sme našli výskyt vzorky v superstringu, no nachádzal sa akurát na rozhraní readov a teda ani jeden read ho neobsahoval.

V tomto momente je dôležité si všimnúť, že týmto spôsobom sme nenašli všetky výskyty vzorky $p=AAT$, napríklad read $GGTAAT$ ju obsahuje, no tento read sme (zatiaľ) na výstup neposunuli. Assemblery totiž pokladajú ready a ich reverzné komplementy za identické a teda sa môže stať, že niektorý kontig bude zložený len z reverzných komplementov -- v našom príklade je to $c_1$. Preto pri zisťovaní výskytu vzorky $p$ potrebujeme vykonať dopyt aj pre $rev\_compl(p)$ a výsledné množinu readov zjednotiť. Pre vzorku $TAA = rev\_compl(AAT)$ nám už FM-index vráti výskyty v superstringu, ktoré potom úspešne preložíme na chýbajúce ready.

Je nutné poznamenať, že realizáciou dotazovania týmto spôsobom vrátime aj ready, ktoré obsahujú reverzný komplement vzorky $p$ -- predstavme si, že by sme robili dotaz pre $p=TACC$, v tom prípade vrátime na výstup aj read $GGTAAT$, ktorý túto vzorku neobsahuje. To je ale v poriadku, keďže to súhlasí s našou definíciou \emph{problému indexovania readov} (viď poslednú odrážku v časti \ref{sec:definicia_problemu}).

\end{example}

\section{Ready s chybami}
Bohužiaľ, zjednodušením situácie vo forme popierania existencie sekvenovacích chýb sa až príliš vzďaľujeme realite. Ako sa teda zmení situácia, ak máme brať do úvahy, že v readoch sa vyskytujú chyby?

Pripomeňme, že pri probléme \emph{indexovania readov} tak, ako sme ho zadefinovali v kapitole \ref{ch:problem_indexovania_readov} uvažujeme len substitučné chyby -- čo znamená, že read sa môže v niektorých bázach líšiť od svojho ,,obrazu`` v pôvodnom genóme.

V prvom rade assembler nebude pri konštrukcii kontigov ani zďaleka tak úspešný ako v predchádzajúcom prípade -- chyby budú znižovať pravdepodobnosť, že úspešne odhalí prekryvy medzi readmi, ciže výstupom assembleru budú oveľa kratšie kontigy, čiže aj ,,kompresný pomer`` bude výrazne nižší a to viac readov bude potrebné pripojiť na koniec. Ak si uvedomíme, že pri indexovaní readov napríklad s dĺžkou 100 báz a chybovosťou $1\%$ má takmer každý read aspoň jednu chybu, vidíme, že tento spôsob indexovania je pre ready s chybami nepostačujúci a komprimáciu vstupu je potrebné robiť sofistikovanejšie.

,,Komprimovateľnosť`` readov zvýšime tak, že pred tým, ako ich dostane assembler na vstup budú opravené -- korekcia readov (\emph{sequencing read correction}) je známy problém, na ktorý existuje množstvo riešení. \todo{sem by sa hodili nejake citacie} Čo nám ale skomplikuje situáciu je fakt, že kontigy budú obsahovať opravené ready a nie originálne, ktoré sme dostali na vstupe -- preto si budeme musieť pamätať aj ďalšie informácie týkajúce sa aplikovaných korekcií, aby sme vedeli prevádzať transformácie medzi opravenými a neopravenými readmi. Tým sme však stále nevyriešili situáciu, čo s chýbajúcimi readmi. Ak by sme v zreťazených kontigoch hľadali pôvodné, neopravené ready, chýbalo by ich, pochopiteľne, veľmi veľa a tým pádom by komprimácia nebola tak úspešná. Zvoľme opačný prístup -- v zreťazených kontigoch budeme hľadať opravené ready a tie, ktoré v kontigoch nie sú obsiahnuté zreťazíme na koniec. Zamyslime sa teraz, ako by prebiehal dotaz -- ak existuje výsky vzorky $p$ v superstringu, znamená to, že nejaký \emph{opravený} read obsahuje hľadanú vzorku. To ale neznamená, že ju obsahoval aj pôvodný read -- našťastie túto situáciu vieme ľahko vyriešiť pomocou zapamätaných korekcií -- k danému opravenému readu skonštruujeme pôvodný a v ňom overíme, či je $p$ jeho podreťazcom. Týmto spôsobom vieme vylúčiť \emph{false positives}. Problematickejšie to bude z druhej strany -- vieme ale takto nájsť \emph{všetky} výskyty vzorky $p$ medzi pôvodnými readmi? Uvažujme nasledovný príklad:

\begin{example}
Uvažujme sadu readov\footnote{Táto sada readov je zámerne extrémne jednoduchá, našim cieľom je len ilustrovať princíp problému} $R=\{AAAAACCC, TAAAACCC, AAAACCCC,$ \\ $ AAGACCCG, CCCCTGTG\}$, kde $l=8$ a $p=6$. Nech korekcie readov vyzerajú nasledovne:

\begin{align*}
AAAAACCC \rightarrow AAAAACCC \\
\mathbf{T}AAAACCC \rightarrow \mathbf{A}AAAACCC \\
AAAACCCC \rightarrow AAAACCCC \\
AA \mathbf{G} ACCC \mathbf{G} \rightarrow AA \mathbf{A} ACCC \mathbf{C} \\
CCC \mathbf{T} TGTG \rightarrow CCC \mathbf{C} TGTG
\end{align*}

Ďalej predpokladajme, že výstupom assemblera spusteného nad opravenými readmi je jeden kontig $c_0=AAAAACCCC$. Po doplnení chýbajúcich \emph{opravených} readov je výstupom superstring $ss=AAAAACCCCCCCCTGTG$. Zamyslime sa teraz, ako by vyzeral dotaz na vzorku $p=TAAAAC$ -- tá sa nachádza v pôvodnom reade $TAAAACCC$, no v superstringu sa už nevyskytuje. Možnosťou by bolo skúsiť vyhľadať všetky vzorky líšiace sa oproti $p$ v jednom znaku, akoby simulovať opravu chyby readu aj vo vzorke. Tým nám lineárne narastie počet dotazov na FM-index nad superstringom. Ak by sme hľadali vzorku $p=GACCCG$ (nachádza sa v pôvodnom reade $AAGACCCG$), potrebovali by sme hľadať ďalej -- výskyt tejto vzorky v pôvodnom reade postihli až dve korekcie. Ak by sme mali vygenerovať všetky možné vzorky líšiace sa od pôvodnej na dvoch miestach, je ich už kvadraticky veľa. Vyzerá to teda, že ani tento prístup, použiť len opravené ready, nebude sláviť úspech. Problematické vyzerajú byť tie ready, v ktorých sú pozície opráv príliš blízko seba -- tak, že by mohli ,,zasiahnúť`` vzorku, t.j. sú bližšie ako $p$.
\end{example}

V konečnom dôsledku teda vidno, že vhodný prístup leží kdesi uprostred možností zreťaziť s kontigmi (nad opravenými readmi) povodné a opravené ready -- budeme sa musieť vhodne vysporiadať s readmi, ktoré majú korekcie ,,príliš blízko seba``.

\section{Navrhovaná implementácia}
V predchádzajúcich častiach sme pojem superstring používali dosť voľne, teraz ho konečne riadne zadefinujeme. Predtým ale ešte uvedieme niektoré označenia a definície.

\subsection{Definície a označenia}

\subsubsection{Substitučná editačná vzdialenosť}
\begin{defn}
Substitučnú editačnú vzdialenosť dvoch reťazcov s a t rovnakej dĺžky l definujeme nasledovne:
$$
edt_s(s, t) = \left\vert{ \{~i~|~0 \leq i < l~\land s[i] \neq t[i] ~\} }\right\vert
$$200/exhibitor/v1/ui/index.html
\end{defn}

Inými slovami, pre dva rovnako dlhé reťazce je to počet pozícií, na ktorých sa líšia.

\begin{example}
$edt_s(ACCTGG, TCCTGC) = 2$
\end{example}

\subsubsection{Superstring}
\begin{defn}
Superstringom množiny reťazcov R rovnakej dĺžky l s parametrom p~$\in \mathbb{N}$ označujeme taký reťazec S, pre ktorý platí, že každý reťazec $r \in R$ spĺňa aspoň jednu z nasledujúcich podmienok:
    \begin{enumerate}[(a)]
    \item r je podreťazcom S
    \item rev\_compl(r) je podreťazcom S
    \item existuje podreťazec s reťazca S s dĺžkou l taký, že 
    $$
    \forall i : 0 \leq i \leq l - p : edt_s(r[i, i+p-1], s[i, i+p-1]) \leq 1
    $$
    \item existuje podreťazec s reťazca S s dĺžkou l taký, že 
    $$
    \forall i : 0 \leq i \leq l - p : edt_s(rev\_compl(r)[i, i+p-1], s[i, i+p-1]) \leq 1
    $$    
    \end{enumerate}

\end{defn}

Povedané inak, superstringom množiny reťazcov $R$ je taký reťazec, v ktorom pre každý reťazec $r$ z $R$ platí, že buď on alebo jeho reverzný komplement je podreťazcom superstringu alebo pre $r$ alebo jeho reverzný komplement vieme nájsť podreťazec superstringu rovnakej dĺžky, ktorý sa od $r$ (resp. jeho reverzného komplentu) ,,líši len tu a tam`` -- to znamená, že indexy, na ktorých majú tieto dva reťazce rôzne znaky nie sú ,,príliš`` blízko seba, t.j. každé dva sú od seba vzdialené aspoň $p$.

%\subsection{Korekcia readov}
% faza korekcie readov

% skonstruujeme pole diff, ready rozdelime na kriticke a nekriticke, definicia tych dvoch veci


% budovanie indexu

% ako sme spominali v predchadzajucej casti, hlavna zmena bude spocitat v tom, ze assembler dostane na vstup opravene ready,ale len nekriticke. queryovat to budeme opravenymi nekritickymi (vysoka sanca, ze tam budu) a originialnymi kritickymi (skoro urcite tam nie su a zretazime ich na koniec, ale nestratime ziadnu informaciu, nebude problem queryovat vzorkou potom). vystupom je fm index nad novym superstringom a polia diff a positions. ukladame si ale len read id, v tych poliach, nie cele ready, lebo chceme setrit pamat a fm index vie rekonstruovat povodny text z indexu. znovu fm index nad superstringom, usortit positions.


% dotazy

% to sa dost masivne zmeni. popis ako to ide + priklad


% mozne zlepsenia

% popisat cca bloom filter, kde a ako by sa dal pouzit